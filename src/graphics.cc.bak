#include "graphics.h"

#include <cstdlib>
#include <iostream>

#include <cmath>

#include "GLES2/gl2.h"
#include "GLES2/gl2ext.h"
#include "SDL/SDL.h"
#define GLM_FORCE_RADIANS
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"

namespace chaos {

GLuint programObject;

int Init()
{
   GLchar vShaderStr[] =
      "attribute vec4 vPosition;   \n"
      "uniform mat4 MVP;           \n"
      "void main()                 \n"
      "{                           \n"
      "  gl_Position = MVP * vPosition;  \n"
      "}                           \n";

   GLchar fShaderStr[] =
      "void main()                                \n"
      "{                                          \n"
      "  gl_FragColor = vec4(0.0, 7.0, 3.0, 1.0); \n"
      "}                                          \n";

   GLuint vertexShader;
   GLuint fragmentShader;
   GLint linked;

  // Load the vertex/fragment shaders
  vertexShader = Graphics::LoadShader(GL_VERTEX_SHADER, vShaderStr);
  fragmentShader = Graphics::LoadShader(GL_FRAGMENT_SHADER, fShaderStr);

  // Create the program object
  programObject = glCreateProgram();

  if(programObject == 0)
     return 0;

  glAttachShader(programObject, vertexShader);
  glAttachShader(programObject, fragmentShader);

  // Bind vPosition to attribute 0
  glBindAttribLocation(programObject, 0, "vPosition");

  // Link the program
  glLinkProgram(programObject);

  // Check the link status
  glGetProgramiv(programObject, GL_LINK_STATUS, &linked);

  if(!linked)
  {
     GLint infoLen = 0;

     glGetProgramiv(programObject, GL_INFO_LOG_LENGTH, &infoLen);

     if(infoLen > 1)
     {
        char* infoLog = (char *)malloc(sizeof(char) * infoLen);

        glGetProgramInfoLog(programObject, infoLen, NULL, infoLog);
        printf("Error linking program:\n%s\n", infoLog);

        free(infoLog);
     }

     glDeleteProgram(programObject);
     return false;
  }

  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

  return true;
}

Graphics::Graphics(SDLHandle &SDL_handle)
  : window_{SDL_handle.window()} {Init();}

void Graphics::Update()
{
  glm::mat4 projection = glm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.0f);
  glm::mat4 view = glm::lookAt(
      glm::vec3(4,3,3),
      glm::vec3(0,0,0),
      glm::vec3(0,1,0));
  glm::mat4 model = glm::mat4(1.0f);

  glm::mat4 mvp = projection * view * model;
  
  GLfloat triangle[] = {
    -1.0f, -1.0f, 0.0f,
     1.0f, -1.0f, 0.0f,
     0.0f,  1.0f, 0.0f,
  };


  // Clear the color buffer
  glClear(GL_COLOR_BUFFER_BIT);

  // Use the program object
  glUseProgram(programObject);

  GLuint matrix_id = glGetUniformLocation(programObject, "MVP");
  glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);

  // Load the vertex data
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, triangle);
  glEnableVertexAttribArray(0);
  glDrawArrays(GL_TRIANGLES, 0, 3);
  SDL_GL_SwapWindow(window_);
}

GLuint Graphics::LoadShader(GLenum type, GLchar const * const shaderSrc)
{
   GLuint shader;
   GLint compiled;

   // Create the shader object
   shader = glCreateShader(type);

   if(shader == 0)
      return 0;

   // Load the shader source
   glShaderSource(shader, 1, &shaderSrc, NULL);

   // Compile the shader
   glCompileShader(shader);

   // Check the compile status
   glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);

   if(!compiled)
   {
      GLint infoLen = 0;

      glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);

      if(infoLen > 1)
      {
         char* infoLog = (char *)malloc(sizeof(char) * infoLen);

         glGetShaderInfoLog(shader, infoLen, NULL, infoLog);
         printf("Error compiling shader:\n%s\n", infoLog);
         free(infoLog);
      }

      glDeleteShader(shader);
      return 0;
   }

   return shader;
}

}  // namespace chaos
